<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>log_format API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>log_format</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># these two packages are used to create python dictionaries form strings
import ast
import json
&#34;&#34;&#34;
Overall Description:
  These classes are to be used once the proper log has been found and can be associated with the correct sub class, all unclassifiable logs can be created with the base class
Author:
  Brandon Parker - park3730
&#34;&#34;&#34;


# Base class ice cream juice
class base_log_format:
    &#34;&#34;&#34;
  Description:
    Used to create log objects from unclassified logs. Overall formatting done in this class is basic since the logs overall format is unknown and not implemented.

  Log type Example(s):
    DEBUG 2021-09-17 18:15:42,567 - http://api.openweathermap.org:80 &#34;GET /data/2.5/weather?q=Waterloo .....  
    INFO 2021-09-17 19:31:13,218 - 172.18.0.1 - - [17/Sep/2021 19:31:13] &#34;HEAD / HTTP/1.1&#34; 200 -
  &#34;&#34;&#34;

    formatted_msg = None
    csv_msg = None
    file_name = &#34;formatted_other_logs_formatted.txt&#34;
    csv_file_name = &#34;csv_other_logs_csv.csv&#34;

    def __init__(self, msg: str):
        self.msg = msg
        # call helper function to create the formatted messages
        self.__format_msg()
        # creates the file names based on their class name except
        # for the base class
        if self.__class__.__name__ != &#34;base_log_format&#34;:
            self.file_name = &#34;formatted_&#34; + self.__class__.__name__ + &#34;.txt&#34;
            self.csv_file_name = &#34;csv_&#34; + self.__class__.__name__ + &#34;.csv&#34;

    def __str__(self):
        return self.msg

    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)
        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]
        # grab the remainder of the log
        info = remainder[6:]
        # create the formated message and CSV
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Notes: {info}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},{info}&#34;

    def wrtie_to_file(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Function to write the formatted message of the log object to the correct file
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;
        # open file for appending
        file = open(&#34;formatted_logs/&#34; + self.file_name, &#34;a&#34;, encoding=&#34;utf-8&#34;)
        # write message to file
        file.write(self.formatted_msg + &#34;\n&#34;)
        # close file
        file.close()

    def write_to_csv(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Function to write the CSV message of the log object to the correct file
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;
        # open file for appending
        file = open(&#34;formatted_logs/&#34; + self.csv_file_name,
                    &#34;a&#34;,
                    encoding=&#34;utf-8&#34;)
        # write message to file
        file.write(self.csv_msg + &#34;\n&#34;)
        # close file
        file.close()


# Dispatch Event Subclass
class dispatch_event_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from disbatch events logs

  Log type Example(s):
    DEBUG 2021-09-17 18:09:19,721 - Dispatching event socket_raw_receive
    DEBUG 2021-09-17 18:09:19,722 - Dispatching event socket_response
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]
        # grab the message
        event_msg = remainder[24:]

        # create formated messages
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Dispatch Event: {event_msg}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},{event_msg}&#34;


# Websocket Event subclass
class websocket_event_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from websocket events logs

  Log type Example(s):
    DEBUG 2021-09-17 18:16:31,681 - For Shard ID None: WebSocket Event: {&#39;t&#39;: None, &#39;s&#39;: None, &#39;op&#39;: 11, &#39;d&#39;: None}
    DEBUG 2021-09-17 18:09:38,843 - For Shard ID None: WebSocket Event: {&#39;t&#39;: &#39;MESSAGE_CREATE&#39;, &#39;s&#39;: 33, &#39;op&#39;: 0, .....
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # gets the dictiionary style infomation from the string
        _, info = remainder[6:].split(&#34;{&#34;, 1)
        info = &#34;{&#34; + info

        # had to use ast package to create dictionary form string as json needs the key to be in double quotes
        info_dict = ast.literal_eval(info)

        # create the parts of the formatted/CSV that will be the same for each log
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code}&#34;

        # create the remaining part of the message based on lof subtype
        if info_dict[&#39;t&#39;] == &#39;MESSAGE_CREATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Author: {info_dict[&#39;d&#39;][&#39;author&#39;][&#39;username&#39;]} Message: {info_dict[&#39;d&#39;][&#39;content&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;author&#39;][&#39;username&#39;]},{info_dict[&#39;d&#39;][&#39;content&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;TYPING_START&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Author: {info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;CHANNEL_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Member ID: {info_dict[&#39;d&#39;][&#39;permission_overwrites&#39;][0][&#39;id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;permission_overwrites&#39;][0][&#39;id&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;VOICE_STATE_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Member: {info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;MESSAGE_DELETE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Channel ID: {info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;MESSAGE_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;CHANNEL_PINS_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Channel ID: {info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;

        else:
            self.formatted_msg += f&#34; | Event Type: miscellaneous&#34;
            self.csv_msg += f&#34;,miscellaneous&#34;


# POST subclass
class POST_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from POST logs

  Log type Example(s):
    DEBUG 2021-09-17 18:10:50,049 - POST https://discord.com/api/v7/channels/887370975526653962/messages with {&#34;content&#34;:&#34;Current temp: 25.7\u00b0C\n .....
    DEBUG 2021-09-17 18:10:50,049 - POST https://discord.com/api/v7/channels/887370975526653962/messages has received {&#39;id&#39;: &#39;888487175790952478&#39;, &#39;type&#39;: 0, .....
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # gets the dictiionary style infomation from the string
        _, remainder = remainder[6:].split(&#34;{&#34;, 1)
        remainder = &#34;{&#34; + remainder

        # Some logs had messages after the string dictionary so i split the message
        data = remainder.split(&#34;} &#34;, 1)

        # if the log had a following message the data would have a length greater than 1
        # which would mean the split function removed the &#34;}&#34; at the end which is
        # needed to create the dictionary. So the &#34;}&#34; is added back on if needed
        if len(data) != 1:
            data[0] += &#34;}&#34;

        # create the parts of the formatted/CSV that will be the same for each log
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code}&#34;

        if len(data) == 1:
            # had to use ast package to create dictionary form string as json needs the key to be in double quotes
            info_dict = ast.literal_eval(data[0])

            # replace all the new line characters in the message with spaces so
            # when written to log file the format is more readable
            info_dict[&#39;content&#39;] = info_dict[&#39;content&#39;].replace(&#34;\n&#34;, &#34; &#34;)

            self.formatted_msg += f&#34; | Author: {info_dict[&#39;author&#39;][&#39;username&#39;]} Message: {info_dict[&#39;content&#39;]} | Channel ID: {info_dict[&#39;channel_id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;author&#39;][&#39;username&#39;]},{info_dict[&#39;content&#39;]},{info_dict[&#39;channel_id&#39;]}&#34;

        else:
            # had to use json to create dictionary from string for characters in utc-16
            info_dict = json.loads(data[0])

            # replace all the new line characters in the message with spaces so
            # when written to log file the format is more readable
            info_dict[&#39;content&#39;] = info_dict[&#39;content&#39;].replace(&#34;\n&#34;, &#34; &#34;)

            self.formatted_msg += f&#34; | Message: {info_dict[&#39;content&#39;]} | Notes: {data[1]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;content&#39;]},{data[1]}&#34;


# Starting new HTTP connection subclass
class HTTP_connection_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from HTTP Connection logs

  Log type Example(s):
    DEBUG 2021-09-17 18:15:42,142 - Starting new HTTP connection (1): api.openweathermap.org:80
    DEBUG 2021-09-17 18:10:49,631 - Starting new HTTP connection (1): api.openweathermap.org:80
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
        Private Helper Method to convert the inital message into a more readable format
        and create a comma seperated version of the message.
    -------------------------------------------
    Return:
        None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # splits the remainder of the information into 2 parts based on &#34;:&#34;
        info = remainder[6:].split(&#34;:&#34;)
        #Strips any white spaces
        info[1] = info[1].strip()

        # creating the formatted messages
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Event: HTTP Connection | Website: {info[1]}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},HTTP Connection,{info[1]}&#34;


# Keeping shard ID None websocket alive subclass
class websocket_alive_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from websocket alive logs

  Log type Example(s):
    DEBUG 2021-09-17 18:10:20,378 - Keeping shard ID None websocket alive with sequence 34.
    DEBUG 2021-09-17 18:11:01,629 - Keeping shard ID None websocket alive with sequence 41.
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
        Private Helper Method to convert the inital message into a more readable format
        and create a comma seperated version of the message.
    -------------------------------------------
    Return:
        None
    &#34;&#34;&#34;
        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # Creates the formatted messages
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Notes: {remainder[6:]}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},{remainder[6:]}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="log_format.HTTP_connection_log"><code class="flex name class">
<span>class <span class="ident">HTTP_connection_log</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Subclass of base_log_format used to create log objects from HTTP Connection logs</p>
<p>Log type Example(s):
DEBUG 2021-09-17 18:15:42,142 - Starting new HTTP connection (1): api.openweathermap.org:80
DEBUG 2021-09-17 18:10:49,631 - Starting new HTTP connection (1): api.openweathermap.org:80</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HTTP_connection_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from HTTP Connection logs

  Log type Example(s):
    DEBUG 2021-09-17 18:15:42,142 - Starting new HTTP connection (1): api.openweathermap.org:80
    DEBUG 2021-09-17 18:10:49,631 - Starting new HTTP connection (1): api.openweathermap.org:80
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
        Private Helper Method to convert the inital message into a more readable format
        and create a comma seperated version of the message.
    -------------------------------------------
    Return:
        None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # splits the remainder of the information into 2 parts based on &#34;:&#34;
        info = remainder[6:].split(&#34;:&#34;)
        #Strips any white spaces
        info[1] = info[1].strip()

        # creating the formatted messages
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Event: HTTP Connection | Website: {info[1]}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},HTTP Connection,{info[1]}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></b></code>:
<ul class="hlist">
<li><code><a title="log_format.base_log_format.write_to_csv" href="#log_format.base_log_format.write_to_csv">write_to_csv</a></code></li>
<li><code><a title="log_format.base_log_format.wrtie_to_file" href="#log_format.base_log_format.wrtie_to_file">wrtie_to_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="log_format.POST_log"><code class="flex name class">
<span>class <span class="ident">POST_log</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Subclass of base_log_format used to create log objects from POST logs</p>
<p>Log type Example(s):
DEBUG 2021-09-17 18:10:50,049 - POST <a href="https://discord.com/api/v7/channels/887370975526653962/messages">https://discord.com/api/v7/channels/887370975526653962/messages</a> with {"content":"Current temp: 25.7°C
.....
DEBUG 2021-09-17 18:10:50,049 - POST <a href="https://discord.com/api/v7/channels/887370975526653962/messages">https://discord.com/api/v7/channels/887370975526653962/messages</a> has received {'id': '888487175790952478', 'type': 0, .....</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class POST_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from POST logs

  Log type Example(s):
    DEBUG 2021-09-17 18:10:50,049 - POST https://discord.com/api/v7/channels/887370975526653962/messages with {&#34;content&#34;:&#34;Current temp: 25.7\u00b0C\n .....
    DEBUG 2021-09-17 18:10:50,049 - POST https://discord.com/api/v7/channels/887370975526653962/messages has received {&#39;id&#39;: &#39;888487175790952478&#39;, &#39;type&#39;: 0, .....
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # gets the dictiionary style infomation from the string
        _, remainder = remainder[6:].split(&#34;{&#34;, 1)
        remainder = &#34;{&#34; + remainder

        # Some logs had messages after the string dictionary so i split the message
        data = remainder.split(&#34;} &#34;, 1)

        # if the log had a following message the data would have a length greater than 1
        # which would mean the split function removed the &#34;}&#34; at the end which is
        # needed to create the dictionary. So the &#34;}&#34; is added back on if needed
        if len(data) != 1:
            data[0] += &#34;}&#34;

        # create the parts of the formatted/CSV that will be the same for each log
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code}&#34;

        if len(data) == 1:
            # had to use ast package to create dictionary form string as json needs the key to be in double quotes
            info_dict = ast.literal_eval(data[0])

            # replace all the new line characters in the message with spaces so
            # when written to log file the format is more readable
            info_dict[&#39;content&#39;] = info_dict[&#39;content&#39;].replace(&#34;\n&#34;, &#34; &#34;)

            self.formatted_msg += f&#34; | Author: {info_dict[&#39;author&#39;][&#39;username&#39;]} Message: {info_dict[&#39;content&#39;]} | Channel ID: {info_dict[&#39;channel_id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;author&#39;][&#39;username&#39;]},{info_dict[&#39;content&#39;]},{info_dict[&#39;channel_id&#39;]}&#34;

        else:
            # had to use json to create dictionary from string for characters in utc-16
            info_dict = json.loads(data[0])

            # replace all the new line characters in the message with spaces so
            # when written to log file the format is more readable
            info_dict[&#39;content&#39;] = info_dict[&#39;content&#39;].replace(&#34;\n&#34;, &#34; &#34;)

            self.formatted_msg += f&#34; | Message: {info_dict[&#39;content&#39;]} | Notes: {data[1]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;content&#39;]},{data[1]}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></b></code>:
<ul class="hlist">
<li><code><a title="log_format.base_log_format.write_to_csv" href="#log_format.base_log_format.write_to_csv">write_to_csv</a></code></li>
<li><code><a title="log_format.base_log_format.wrtie_to_file" href="#log_format.base_log_format.wrtie_to_file">wrtie_to_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="log_format.base_log_format"><code class="flex name class">
<span>class <span class="ident">base_log_format</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Used to create log objects from unclassified logs. Overall formatting done in this class is basic since the logs overall format is unknown and not implemented.</p>
<p>Log type Example(s):
DEBUG 2021-09-17 18:15:42,567 - <a href="http://api.openweathermap.org:80">http://api.openweathermap.org:80</a> "GET /data/2.5/weather?q=Waterloo .....<br>
INFO 2021-09-17 19:31:13,218 - 172.18.0.1 - - [17/Sep/2021 19:31:13] "HEAD / HTTP/1.1" 200 -</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class base_log_format:
    &#34;&#34;&#34;
  Description:
    Used to create log objects from unclassified logs. Overall formatting done in this class is basic since the logs overall format is unknown and not implemented.

  Log type Example(s):
    DEBUG 2021-09-17 18:15:42,567 - http://api.openweathermap.org:80 &#34;GET /data/2.5/weather?q=Waterloo .....  
    INFO 2021-09-17 19:31:13,218 - 172.18.0.1 - - [17/Sep/2021 19:31:13] &#34;HEAD / HTTP/1.1&#34; 200 -
  &#34;&#34;&#34;

    formatted_msg = None
    csv_msg = None
    file_name = &#34;formatted_other_logs_formatted.txt&#34;
    csv_file_name = &#34;csv_other_logs_csv.csv&#34;

    def __init__(self, msg: str):
        self.msg = msg
        # call helper function to create the formatted messages
        self.__format_msg()
        # creates the file names based on their class name except
        # for the base class
        if self.__class__.__name__ != &#34;base_log_format&#34;:
            self.file_name = &#34;formatted_&#34; + self.__class__.__name__ + &#34;.txt&#34;
            self.csv_file_name = &#34;csv_&#34; + self.__class__.__name__ + &#34;.csv&#34;

    def __str__(self):
        return self.msg

    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)
        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]
        # grab the remainder of the log
        info = remainder[6:]
        # create the formated message and CSV
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Notes: {info}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},{info}&#34;

    def wrtie_to_file(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Function to write the formatted message of the log object to the correct file
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;
        # open file for appending
        file = open(&#34;formatted_logs/&#34; + self.file_name, &#34;a&#34;, encoding=&#34;utf-8&#34;)
        # write message to file
        file.write(self.formatted_msg + &#34;\n&#34;)
        # close file
        file.close()

    def write_to_csv(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Function to write the CSV message of the log object to the correct file
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;
        # open file for appending
        file = open(&#34;formatted_logs/&#34; + self.csv_file_name,
                    &#34;a&#34;,
                    encoding=&#34;utf-8&#34;)
        # write message to file
        file.write(self.csv_msg + &#34;\n&#34;)
        # close file
        file.close()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="log_format.HTTP_connection_log" href="#log_format.HTTP_connection_log">HTTP_connection_log</a></li>
<li><a title="log_format.POST_log" href="#log_format.POST_log">POST_log</a></li>
<li><a title="log_format.dispatch_event_log" href="#log_format.dispatch_event_log">dispatch_event_log</a></li>
<li><a title="log_format.websocket_alive_log" href="#log_format.websocket_alive_log">websocket_alive_log</a></li>
<li><a title="log_format.websocket_event_log" href="#log_format.websocket_event_log">websocket_event_log</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="log_format.base_log_format.csv_file_name"><code class="name">var <span class="ident">csv_file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="log_format.base_log_format.csv_msg"><code class="name">var <span class="ident">csv_msg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="log_format.base_log_format.file_name"><code class="name">var <span class="ident">file_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="log_format.base_log_format.formatted_msg"><code class="name">var <span class="ident">formatted_msg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="log_format.base_log_format.write_to_csv"><code class="name flex">
<span>def <span class="ident">write_to_csv</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<h2 id="function-to-write-the-csv-message-of-the-log-object-to-the-correct-file">Function To Write The Csv Message Of The Log Object To The Correct File</h2>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_to_csv(self) -&gt; None:
    &#34;&#34;&#34;
Description:
  Function to write the CSV message of the log object to the correct file
-------------------------------------------
Return:
  None
&#34;&#34;&#34;
    # open file for appending
    file = open(&#34;formatted_logs/&#34; + self.csv_file_name,
                &#34;a&#34;,
                encoding=&#34;utf-8&#34;)
    # write message to file
    file.write(self.csv_msg + &#34;\n&#34;)
    # close file
    file.close()</code></pre>
</details>
</dd>
<dt id="log_format.base_log_format.wrtie_to_file"><code class="name flex">
<span>def <span class="ident">wrtie_to_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<h2 id="function-to-write-the-formatted-message-of-the-log-object-to-the-correct-file">Function To Write The Formatted Message Of The Log Object To The Correct File</h2>
<h2 id="return">Return</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrtie_to_file(self) -&gt; None:
    &#34;&#34;&#34;
Description:
  Function to write the formatted message of the log object to the correct file
-------------------------------------------
Return:
  None
&#34;&#34;&#34;
    # open file for appending
    file = open(&#34;formatted_logs/&#34; + self.file_name, &#34;a&#34;, encoding=&#34;utf-8&#34;)
    # write message to file
    file.write(self.formatted_msg + &#34;\n&#34;)
    # close file
    file.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="log_format.dispatch_event_log"><code class="flex name class">
<span>class <span class="ident">dispatch_event_log</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Subclass of base_log_format used to create log objects from disbatch events logs</p>
<p>Log type Example(s):
DEBUG 2021-09-17 18:09:19,721 - Dispatching event socket_raw_receive
DEBUG 2021-09-17 18:09:19,722 - Dispatching event socket_response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dispatch_event_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from disbatch events logs

  Log type Example(s):
    DEBUG 2021-09-17 18:09:19,721 - Dispatching event socket_raw_receive
    DEBUG 2021-09-17 18:09:19,722 - Dispatching event socket_response
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]
        # grab the message
        event_msg = remainder[24:]

        # create formated messages
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Dispatch Event: {event_msg}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},{event_msg}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></b></code>:
<ul class="hlist">
<li><code><a title="log_format.base_log_format.write_to_csv" href="#log_format.base_log_format.write_to_csv">write_to_csv</a></code></li>
<li><code><a title="log_format.base_log_format.wrtie_to_file" href="#log_format.base_log_format.wrtie_to_file">wrtie_to_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="log_format.websocket_alive_log"><code class="flex name class">
<span>class <span class="ident">websocket_alive_log</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Subclass of base_log_format used to create log objects from websocket alive logs</p>
<p>Log type Example(s):
DEBUG 2021-09-17 18:10:20,378 - Keeping shard ID None websocket alive with sequence 34.
DEBUG 2021-09-17 18:11:01,629 - Keeping shard ID None websocket alive with sequence 41.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class websocket_alive_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from websocket alive logs

  Log type Example(s):
    DEBUG 2021-09-17 18:10:20,378 - Keeping shard ID None websocket alive with sequence 34.
    DEBUG 2021-09-17 18:11:01,629 - Keeping shard ID None websocket alive with sequence 41.
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
        Private Helper Method to convert the inital message into a more readable format
        and create a comma seperated version of the message.
    -------------------------------------------
    Return:
        None
    &#34;&#34;&#34;
        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # Creates the formatted messages
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code} | Notes: {remainder[6:]}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code},{remainder[6:]}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></b></code>:
<ul class="hlist">
<li><code><a title="log_format.base_log_format.write_to_csv" href="#log_format.base_log_format.write_to_csv">write_to_csv</a></code></li>
<li><code><a title="log_format.base_log_format.wrtie_to_file" href="#log_format.base_log_format.wrtie_to_file">wrtie_to_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="log_format.websocket_event_log"><code class="flex name class">
<span>class <span class="ident">websocket_event_log</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Subclass of base_log_format used to create log objects from websocket events logs</p>
<p>Log type Example(s):
DEBUG 2021-09-17 18:16:31,681 - For Shard ID None: WebSocket Event: {'t': None, 's': None, 'op': 11, 'd': None}
DEBUG 2021-09-17 18:09:38,843 - For Shard ID None: WebSocket Event: {'t': 'MESSAGE_CREATE', 's': 33, 'op': 0, .....</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class websocket_event_log(base_log_format):
    &#34;&#34;&#34;
  Description:
    Subclass of base_log_format used to create log objects from websocket events logs

  Log type Example(s):
    DEBUG 2021-09-17 18:16:31,681 - For Shard ID None: WebSocket Event: {&#39;t&#39;: None, &#39;s&#39;: None, &#39;op&#39;: 11, &#39;d&#39;: None}
    DEBUG 2021-09-17 18:09:38,843 - For Shard ID None: WebSocket Event: {&#39;t&#39;: &#39;MESSAGE_CREATE&#39;, &#39;s&#39;: 33, &#39;op&#39;: 0, .....
  &#34;&#34;&#34;
    def __format_msg(self) -&gt; None:
        &#34;&#34;&#34;
    Description:
      Private Helper Method to convert the inital message into a more readable format and create a comma seperated version of the message.
    -------------------------------------------
    Return:
      None
    &#34;&#34;&#34;

        # splits data into the the time stamp and remainder portiosn of the log
        type_and_timestamp, remainder = self.msg.split(&#39;,&#39;, 1)

        # grab just the timestamp
        timestamp = type_and_timestamp[-19:]
        # grab just the msg type
        msg_type = type_and_timestamp[:-20]
        # grab the code
        code = remainder[:3]

        # gets the dictiionary style infomation from the string
        _, info = remainder[6:].split(&#34;{&#34;, 1)
        info = &#34;{&#34; + info

        # had to use ast package to create dictionary form string as json needs the key to be in double quotes
        info_dict = ast.literal_eval(info)

        # create the parts of the formatted/CSV that will be the same for each log
        self.formatted_msg = f&#34;Type: {msg_type} | Timestamp: {timestamp} | Code: {code}&#34;
        self.csv_msg = f&#34;{msg_type},{timestamp},{code}&#34;

        # create the remaining part of the message based on lof subtype
        if info_dict[&#39;t&#39;] == &#39;MESSAGE_CREATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Author: {info_dict[&#39;d&#39;][&#39;author&#39;][&#39;username&#39;]} Message: {info_dict[&#39;d&#39;][&#39;content&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;author&#39;][&#39;username&#39;]},{info_dict[&#39;d&#39;][&#39;content&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;TYPING_START&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Author: {info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;CHANNEL_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Member ID: {info_dict[&#39;d&#39;][&#39;permission_overwrites&#39;][0][&#39;id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;permission_overwrites&#39;][0][&#39;id&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;VOICE_STATE_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Member: {info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;member&#39;][&#39;user&#39;][&#39;username&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;MESSAGE_DELETE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Channel ID: {info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;MESSAGE_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]}&#34;

        elif info_dict[&#39;t&#39;] == &#39;CHANNEL_PINS_UPDATE&#39;:
            self.formatted_msg += f&#34; | Event Type: {info_dict[&#39;t&#39;]} | Channel ID: {info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;
            self.csv_msg += f&#34;,{info_dict[&#39;t&#39;]},{info_dict[&#39;d&#39;][&#39;channel_id&#39;]}&#34;

        else:
            self.formatted_msg += f&#34; | Event Type: miscellaneous&#34;
            self.csv_msg += f&#34;,miscellaneous&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></b></code>:
<ul class="hlist">
<li><code><a title="log_format.base_log_format.write_to_csv" href="#log_format.base_log_format.write_to_csv">write_to_csv</a></code></li>
<li><code><a title="log_format.base_log_format.wrtie_to_file" href="#log_format.base_log_format.wrtie_to_file">wrtie_to_file</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="log_format.HTTP_connection_log" href="#log_format.HTTP_connection_log">HTTP_connection_log</a></code></h4>
</li>
<li>
<h4><code><a title="log_format.POST_log" href="#log_format.POST_log">POST_log</a></code></h4>
</li>
<li>
<h4><code><a title="log_format.base_log_format" href="#log_format.base_log_format">base_log_format</a></code></h4>
<ul class="two-column">
<li><code><a title="log_format.base_log_format.csv_file_name" href="#log_format.base_log_format.csv_file_name">csv_file_name</a></code></li>
<li><code><a title="log_format.base_log_format.csv_msg" href="#log_format.base_log_format.csv_msg">csv_msg</a></code></li>
<li><code><a title="log_format.base_log_format.file_name" href="#log_format.base_log_format.file_name">file_name</a></code></li>
<li><code><a title="log_format.base_log_format.formatted_msg" href="#log_format.base_log_format.formatted_msg">formatted_msg</a></code></li>
<li><code><a title="log_format.base_log_format.write_to_csv" href="#log_format.base_log_format.write_to_csv">write_to_csv</a></code></li>
<li><code><a title="log_format.base_log_format.wrtie_to_file" href="#log_format.base_log_format.wrtie_to_file">wrtie_to_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="log_format.dispatch_event_log" href="#log_format.dispatch_event_log">dispatch_event_log</a></code></h4>
</li>
<li>
<h4><code><a title="log_format.websocket_alive_log" href="#log_format.websocket_alive_log">websocket_alive_log</a></code></h4>
</li>
<li>
<h4><code><a title="log_format.websocket_event_log" href="#log_format.websocket_event_log">websocket_event_log</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>